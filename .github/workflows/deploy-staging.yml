name: Deploy to Staging

on:
  push:
    branches: [staging, develop]
  pull_request:
    branches: [staging]
    types: [closed]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  IMAGE_NAME: trendsearth-api
  COMPOSE_FILE: docker-compose.staging.yml

jobs:
  build-and-deploy:
    name: Build and Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

    - name: Get runner IP and update security group
      id: security-group
      run: |
        # Get the public IP of the GitHub Actions runner
        RUNNER_IP=$(curl -s https://checkip.amazonaws.com)
        echo "Runner IP: $RUNNER_IP"
        echo "runner-ip=$RUNNER_IP" >> $GITHUB_OUTPUT
        
        # Add SSH access rule for the runner IP
        echo "Adding SSH access for runner IP $RUNNER_IP to security group ${{ secrets.STAGING_SECURITY_GROUP_ID }}"
        aws ec2 authorize-security-group-ingress \
          --group-id "${{ secrets.STAGING_SECURITY_GROUP_ID }}" \
          --protocol tcp \
          --port 22 \
          --cidr "${RUNNER_IP}/32" || true
        
        echo "Security group rule added successfully"

    - name: Set SSH port variable
      id: ssh-port
      run: |
        # Trim whitespace and newlines from the port
        PORT="${{ secrets.STAGING_SSH_PORT || 22 }}"
        PORT=$(echo "$PORT" | tr -d '[:space:]')
        echo "port=$PORT" >> $GITHUB_OUTPUT

    - name: Check for concurrent deployments
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          LOCK_FILE="/tmp/staging-deployment.lock"
          
          # Check if a deployment is already in progress
          if [ -f "$LOCK_FILE" ]; then
            LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
            if [ -n "$LOCK_PID" ] && kill -0 "$LOCK_PID" 2>/dev/null; then
              echo "‚ùå Another deployment is already in progress (PID: $LOCK_PID)"
              echo "Please wait for the current deployment to complete before starting a new one"
              exit 1
            else
              echo "üßπ Removing stale lock file"
              rm -f "$LOCK_FILE"
            fi
          fi
          
          # Create lock file with current process ID
          echo $$ > "$LOCK_FILE"
          echo "üîí Deployment lock acquired"

    - name: Build and push image on staging server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üìö Starting staging deployment build process..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          # Determine which branch to deploy
          BRANCH="${{ github.ref_name == 'staging' && 'staging' || 'develop' }}"
          echo "üìö Deploying branch: $BRANCH"
          
          # Clean git workspace and checkout correct branch using deployment utilities
          # Note: We run this before chmod to ensure deployment_utils.py exists
          if ! python3 deployment_utils.py \
            --registry "${{ env.REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}" \
            clean-git --branch "$BRANCH"; then
            echo "‚ùå Git workspace cleaning failed"
            exit 1
          fi
          
          # Verify deployment utilities exist after git cleanup
          if [ ! -f "deployment_utils.py" ]; then
            echo "‚ùå deployment_utils.py not found after git cleanup"
            echo "üìã Current directory contents:"
            ls -la
            exit 1
          fi
          
          # Ensure deployment utilities are executable after git cleanup
          chmod +x deployment_utils.py
          
          # Configure Docker registry using deployment utilities
          if ! python3 deployment_utils.py \
            --registry "${{ env.REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}" \
            configure-registry; then
            echo "‚ùå Docker registry configuration failed"
            exit 1
          fi
          
          # Create image tags for staging deployment
          BRANCH_NAME="${{ github.ref_name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          
          # Build and push images using deployment utilities
          if ! python3 deployment_utils.py \
            --registry "${{ env.REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}" \
            build-image \
            --tags "$BRANCH_NAME" "$BRANCH_NAME-$SHORT_SHA" "staging" \
            --commit-sha "${{ github.sha }}" \
            --no-cache; then
            echo "‚ùå Docker image build and push failed"
            exit 1
          fi
          
          echo "‚úÖ Staging deployment build process completed!"

    - name: Deploy to EC2 Staging
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üöÄ Starting staging deployment..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          export DOCKER_REGISTRY="${{ secrets.DOCKER_REGISTRY }}"

          # Load and export critical environment variables from staging.env
          # These are required for Docker network creation
          export DOCKER_SUBNET=$(grep "^DOCKER_SUBNET=" staging.env | cut -d'=' -f2 || echo "10.1.0.0/16")
          export EXECUTION_SUBNET=$(grep "^EXECUTION_SUBNET=" staging.env | cut -d'=' -f2 || echo "10.2.0.0/24")

          # Set staging database environment variables
          export STAGING_DB_NAME="${{ secrets.STAGING_DB_NAME }}"
          export STAGING_DB_USER="${{ secrets.STAGING_DB_USER }}"
          export STAGING_DB_PASSWORD="${{ secrets.STAGING_DB_PASSWORD }}"
          
          # Set production database environment variables for data migration
          export PROD_DB_HOST="${{ secrets.PROD_DB_HOST }}"
          export PROD_DB_PORT="${{ secrets.PROD_DB_PORT }}"
          export PROD_DB_NAME="${{ secrets.PROD_DB_NAME }}"
          export PROD_DB_USER="${{ secrets.PROD_DB_USER }}"
          export PROD_DB_PASSWORD="${{ secrets.PROD_DB_PASSWORD }}"
          
          # Set test user credentials for staging environment setup
          export TEST_SUPERADMIN_EMAIL="${{ secrets.TEST_SUPERADMIN_EMAIL }}"
          export TEST_ADMIN_EMAIL="${{ secrets.TEST_ADMIN_EMAIL }}"
          export TEST_USER_EMAIL="${{ secrets.TEST_USER_EMAIL }}"
          export TEST_SUPERADMIN_PASSWORD="${{ secrets.TEST_SUPERADMIN_PASSWORD }}"
          export TEST_ADMIN_PASSWORD="${{ secrets.TEST_ADMIN_PASSWORD }}"
          export TEST_USER_PASSWORD="${{ secrets.TEST_USER_PASSWORD }}"
          
          # Set version information for health checks
          export GIT_COMMIT_SHA="${{ github.sha }}"
          export GIT_BRANCH="${{ github.ref_name }}"
          export DEPLOYMENT_ENVIRONMENT="staging"
          
          # Verify environment variables are set correctly
          echo "üìã Environment variables:"
          echo "  DOCKER_REGISTRY: $DOCKER_REGISTRY"
          echo "  DOCKER_SUBNET: $DOCKER_SUBNET"
          echo "  EXECUTION_SUBNET: $EXECUTION_SUBNET"
          echo "  GIT_COMMIT_SHA: $GIT_COMMIT_SHA"
          echo "  GIT_BRANCH: $GIT_BRANCH"
          echo "  STAGING_DB_NAME: $STAGING_DB_NAME"
          echo "  PROD_DB_HOST: $PROD_DB_HOST"
          echo "  TEST_SUPERADMIN_EMAIL: $TEST_SUPERADMIN_EMAIL"
          
          # Deploy with Docker Swarm using rolling updates
          echo "üì¶ Deploying services with rolling updates..."
          
          # Clean up any corrupted networks that might prevent deployment
          echo "üåê Cleaning up overlay networks..."
          if docker network ls --format "{{.Name}}" | grep -q "trends-earth-staging_backend"; then
            echo "Removing existing network trends-earth-staging_backend..."
            # Force remove network even if it has active endpoints
            docker network rm trends-earth-staging_backend --force || true
            echo "‚úÖ Backend network cleanup completed"
            sleep 3
          fi
          
          if docker network ls --format "{{.Name}}" | grep -q "trends-earth-staging_execution"; then
            echo "Removing existing network trends-earth-staging_execution..."
            # Force remove network even if it has active endpoints
            docker network rm trends-earth-staging_execution --force || true
            echo "‚úÖ Execution network cleanup completed"
            sleep 3
          fi
          
          # Ensure we're using the latest compose file
          echo "üìã Verifying compose file..."
          if [ ! -f "${{ env.COMPOSE_FILE }}" ]; then
            echo "‚ùå Compose file not found: ${{ env.COMPOSE_FILE }}"
            exit 1
          fi
          
          # Deploy services using production-inspired approach
          echo "üì¶ Deploying services..."
          
          # Check if execution services are running that would prevent clean stack removal
          # For staging, we're less concerned about preserving executions but still check for safety
          active_executions=$(docker service ls --filter "label=service.type=execution" --format "{{.Name}}" | wc -l)
          if [ "$active_executions" -eq 0 ]; then
            # Fallback detection by name pattern if labels are missing
            active_executions=$(docker service ls --filter "name=execution-" --format "{{.Name}}" | wc -l)
          fi
          
          if [ $active_executions -gt 0 ]; then
            echo "‚ö†Ô∏è Found $active_executions active execution services - using rolling update instead of stack removal"
            echo "Active executions:"
            docker service ls --filter "name=execution-" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
            
            echo "üîÑ Performing rolling update deployment..."
            attempts=0
            until docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-staging; do
              attempts=$((attempts+1))
              if [ "$attempts" -ge 3 ]; then
                echo "‚ùå Stack deploy failed after $attempts attempts"
                exit 1
              fi
              echo "‚è≥ Stack deploy failed, retrying in 5s (attempt $attempts/3)..."
              sleep 5
            done
            
          else
            echo "No active executions found - performing clean stack deployment"
            # Safe to remove and redeploy stack for staging
            if docker stack ls --format "{{.Name}}" | grep -q "trends-earth-staging"; then
              echo "Removing existing stack trends-earth-staging..."
              docker stack rm trends-earth-staging
              
              # Wait for complete cleanup
              echo "‚è≥ Waiting for stack cleanup to complete..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if ! docker service ls --format "{{.Name}}" | grep -q "trends-earth-staging"; then
                  echo "‚úÖ Stack cleanup completed"
                  break
                fi
                echo "‚è≥ Waiting for services to stop... ($timeout seconds remaining)"
                sleep 5
                timeout=$((timeout - 5))
              done
              
              # Wait for networks to be cleaned up
              sleep 10
              echo "‚úÖ Stack removal completed"
            fi
            
            # Deploy fresh stack
            echo "üöÄ Deploying fresh stack..."
            attempts=0
            until docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-staging; do
              attempts=$((attempts+1))
              if [ "$attempts" -ge 3 ]; then
                echo "‚ùå Stack deploy failed after $attempts attempts"
                exit 1
              fi
              echo "‚è≥ Stack deploy failed, retrying in 5s (attempt $attempts/3)..."
              sleep 5
            done
          fi
          
          # Wait for rolling update to complete
          echo "‚è≥ Waiting for rolling update to complete..."
          
          # Monitor services for successful deployment
          echo "üìä Monitoring service deployment..."
          max_wait=180
          wait_time=0
          
          while [ $wait_time -lt $max_wait ]; do
            # Get the current state of services
            services_status=$(docker service ls --filter "name=trends-earth-staging" --format "{{.Name}}\t{{.Replicas}}")
            
            # Check if all services are converged (not updating)
            updating_services=$(docker service ls --filter "name=trends-earth-staging" --format "{{.Name}}\t{{.UpdateStatus}}" | grep -v "completed\|paused\|" | wc -l)
            
            if [ "$updating_services" -eq 0 ]; then
              # Check if all desired replicas are running
              pending_services=$(echo "$services_status" | grep -v "1/1" | grep -v "migrate" | wc -l)
              
              if [ "$pending_services" -eq 0 ]; then
                echo "‚úÖ All services successfully deployed and running"
                break
              else
                echo "‚è≥ Waiting for services to reach desired state..."
              fi
            else
              echo "‚è≥ Rolling update in progress for $updating_services service(s)..."
            fi
            
            echo "Current service status:"
            echo "$services_status"
            
            sleep 10
            wait_time=$((wait_time + 10))
          done
          
          if [ $wait_time -ge $max_wait ]; then
            echo "‚ö†Ô∏è Rolling update did not complete within $max_wait seconds"
            echo "üîç Current service status:"
            docker service ls --filter "name=trends-earth-staging" --format "table {{.Name}}\t{{.Replicas}}\t{{.UpdateStatus}}"
            
            echo "ÔøΩ Checking for failed services..."
            failed_services=$(docker service ls --filter "name=trends-earth-staging" --format "{{.Name}}\t{{.UpdateStatus}}" | grep "paused\|rollback_paused" || true)
            
            if [ -n "$failed_services" ]; then
              echo "‚ùå Some services failed to update:"
              echo "$failed_services"
              echo "üîÑ Automatic rollback will be handled by health check step"
            else
              echo "‚ö†Ô∏è Services may still be updating - proceeding to health check"
            fi
          fi
          
          # Wait for all services to be ready using deployment utilities
          echo "üìä Waiting for all services to be running..."
          if ! python3 deployment_utils.py \
            --registry "${{ secrets.DOCKER_REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}" \
            wait-services --stack-name "trends-earth-staging" --max-wait 120; then
            echo "‚ö†Ô∏è Some services may not be fully ready, but continuing..."
          fi
          
          # Check service status
          echo "üìä Final service status:"
          docker service ls | grep trends-earth-staging
          
          # Health check using deployment utilities
          echo "üè• Performing health check..."
          if ! python3 deployment_utils.py \
            --registry "${{ secrets.DOCKER_REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}" \
            health-check --port 3002 --max-attempts 30; then
            echo "‚ùå Health check failed"
            echo "üîç Final debugging information:"
            echo "  - All running containers:"
            docker ps --filter "name=trends-earth-staging"
            echo "  - API service details:"
            docker service inspect trends-earth-staging_api --format="{{json .Spec.TaskTemplate.ContainerSpec}}" || echo "Service not found"
            echo "  - Recent API service logs:"
            docker service logs --tail 50 trends-earth-staging_api || echo "No logs available"
            exit 1
          fi
          
          echo "üéâ Initial service deployment completed successfully!"

    - name: Wait for Database Migration and Setup
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          echo "üóÑÔ∏è Waiting for migrate service to complete database setup..."
          max_wait=300  # 5 minutes
          wait_time=0
          
          while [ $wait_time -lt $max_wait ]; do
            # Check if migrate service has completed (it should exit after migrations)
            migrate_status=$(docker service ps trends-earth-staging_migrate --format "{{.CurrentState}}" --no-trunc | head -1)
            
            if echo "$migrate_status" | grep -q "Complete"; then
              echo "‚úÖ Database migration and staging setup completed successfully"
              echo "üìã Migrate service final status: $migrate_status"
              break
            elif echo "$migrate_status" | grep -q "Failed"; then
              echo "‚ùå Database migration failed"
              echo "ÔøΩ Migrate service status: $migrate_status"
              echo "üîç Migrate service logs:"
              docker service logs --tail 50 trends-earth-staging_migrate || echo "No logs available"
              exit 1
            else
              echo "‚è≥ Waiting for migrate service to complete... ($wait_time/$max_wait seconds)"
              echo "üìã Current status: $migrate_status"
              sleep 10
              wait_time=$((wait_time + 10))
            fi
          done
          
          if [ $wait_time -ge $max_wait ]; then
            echo "‚ùå Migration service did not complete within $max_wait seconds"
            echo "üîç Final migrate service status:"
            docker service ps trends-earth-staging_migrate --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}"
            echo "üîç Migrate service logs:"
            docker service logs --tail 100 trends-earth-staging_migrate || echo "No logs available"
            exit 1
          fi
          
          # Display setup completion info
          echo "üéâ Staging environment setup completed!"
          echo "üìù The following was automatically configured by the migrate service:"
          echo "   ‚Ä¢ Database migrations applied"
          echo "   ‚Ä¢ Test users created with credentials from GitHub secrets"
          echo "   ‚Ä¢ Production data imported (scripts, status logs)"
          echo "   ‚Ä¢ Setup verification completed"
          echo ""
          echo "üîç To check migrate service logs: docker service logs trends-earth-staging_migrate"

    - name: Run integration tests
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          # Set test user credentials for integration tests
          export TEST_SUPERADMIN_EMAIL="${{ secrets.TEST_SUPERADMIN_EMAIL }}"
          export TEST_ADMIN_EMAIL="${{ secrets.TEST_ADMIN_EMAIL }}"
          export TEST_USER_EMAIL="${{ secrets.TEST_USER_EMAIL }}"
          export TEST_SUPERADMIN_PASSWORD="${{ secrets.TEST_SUPERADMIN_PASSWORD }}"
          export TEST_ADMIN_PASSWORD="${{ secrets.TEST_ADMIN_PASSWORD }}"
          export TEST_USER_PASSWORD="${{ secrets.TEST_USER_PASSWORD }}"
          
          # Run integration tests script
          chmod +x scripts/deployment/run-integration-tests.sh
          ./scripts/deployment/run-integration-tests.sh

    - name: Notify Rollbar of deployment
      if: success()
      run: |
        echo "üîî Notifying Rollbar of successful deployment..."
        
        # Get deployment information
        ENVIRONMENT="staging"
        REVISION="${{ github.sha }}"
        LOCAL_USERNAME="${{ github.actor }}"
        COMMENT="Deployed to staging via GitHub Actions - Branch: ${{ github.ref_name }}, Commit: ${REVISION:0:7}"
        
        # Send deployment notification to Rollbar
        curl -X POST 'https://api.rollbar.com/api/1/deploy/' \
          -H 'Content-Type: application/json' \
          -d '{
            "access_token": "${{ secrets.ROLLBAR_SERVER_ACCESS_TOKEN }}",
            "environment": "'"$ENVIRONMENT"'",
            "revision": "'"$REVISION"'",
            "local_username": "'"$LOCAL_USERNAME"'",
            "comment": "'"$COMMENT"'"
          }'
        
        echo "‚úÖ Rollbar deployment notification sent successfully"
        
    - name: Cleanup deployment lock
      if: always()
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          # Remove deployment lock file
          LOCK_FILE="/tmp/staging-deployment.lock"
          if [ -f "$LOCK_FILE" ]; then
            rm -f "$LOCK_FILE"
            echo "üîì Deployment lock released"
          fi

    - name: Cleanup security group access
      if: always()
      run: |
        # Remove the SSH access rule for the runner IP
        RUNNER_IP="${{ steps.security-group.outputs.runner-ip }}"
        if [ -n "$RUNNER_IP" ]; then
          echo "Removing SSH access for runner IP $RUNNER_IP from security group ${{ secrets.STAGING_SECURITY_GROUP_ID }}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ secrets.STAGING_SECURITY_GROUP_ID }}" \
            --protocol tcp \
            --port 22 \
            --cidr "${RUNNER_IP}/32" || true
          echo "Security group rule removed successfully"
        else
          echo "No runner IP found to remove from security group"
        fi