name: Deploy to Staging

on:
  push:
    branches: [staging, develop]
  pull_request:
    branches: [staging]
    types: [closed]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  IMAGE_NAME: trendsearth-api-staging
  COMPOSE_FILE: docker-compose.staging.yml

jobs:
  build-and-deploy:
    name: Build and Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

    - name: Get runner IP and update security group
      id: security-group
      run: |
        # Get the public IP of the GitHub Actions runner
        RUNNER_IP=$(curl -s https://checkip.amazonaws.com)
        echo "Runner IP: $RUNNER_IP"
        echo "runner-ip=$RUNNER_IP" >> $GITHUB_OUTPUT
        
        # Add SSH access rule for the runner IP
        echo "Adding SSH access for runner IP $RUNNER_IP to security group ${{ secrets.STAGING_SECURITY_GROUP_ID }}"
        aws ec2 authorize-security-group-ingress \
          --group-id "${{ secrets.STAGING_SECURITY_GROUP_ID }}" \
          --protocol tcp \
          --port 22 \
          --cidr "${RUNNER_IP}/32" || true
        
        echo "Security group rule added successfully"

    - name: Set SSH port variable
      id: ssh-port
      run: |
        # Trim whitespace and newlines from the port
        PORT="${{ secrets.STAGING_SSH_PORT || 22 }}"
        PORT=$(echo "$PORT" | tr -d '[:space:]')
        echo "port=$PORT" >> $GITHUB_OUTPUT

    - name: Build and push image on staging server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "ÔøΩ Building Docker image on staging server..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          # Pull latest changes and checkout the correct branch
          git fetch origin
          
          # Determine which branch to deploy and checkout
          if [ "${{ github.ref_name }}" = "staging" ]; then
            echo "üîÑ Checking out staging branch..."
            git checkout staging
            git reset --hard origin/staging
          else
            echo "üîÑ Checking out develop branch..."
            git checkout develop
            git reset --hard origin/develop
          fi
          
          echo "‚úÖ Currently on branch: $(git branch --show-current)"
          
          # Configure insecure registry on server if needed
          echo "üìã Configuring insecure registry on server..."
          sudo mkdir -p /etc/docker
          if [ ! -f /etc/docker/daemon.json ] || ! grep -q "insecure-registries" /etc/docker/daemon.json; then
            echo '{"insecure-registries":["${{ env.REGISTRY }}"]}' | sudo tee /etc/docker/daemon.json > /dev/null
            sudo systemctl restart docker
            sleep 10
          fi
          
          # Configure Docker client authentication
          mkdir -p $HOME/.docker
          
          # Create simplified Docker config without auth for staging
          echo "üîê Creating Docker config for staging..."
          cat > $HOME/.docker/config.json <<-DOCKERCONFIG
          {
            "insecure-registries": ["${{ env.REGISTRY }}"]
          }
          DOCKERCONFIG
          echo "‚úÖ Docker config created successfully"
          
          # Build the image with the appropriate tags
          echo "üî® Building Docker image..."
          
          # Create staging-specific tags
          REGISTRY="${{ env.REGISTRY }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          BRANCH_NAME="${{ github.ref_name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          
          BUILT_TAGS="$REGISTRY/$IMAGE_NAME:$BRANCH_NAME
          $REGISTRY/$IMAGE_NAME:$BRANCH_NAME-$SHORT_SHA
          $REGISTRY/$IMAGE_NAME:staging"
          
          # Build with the first tag (primary tag)
          PRIMARY_TAG="$REGISTRY/$IMAGE_NAME:$BRANCH_NAME"
          echo "Building with primary tag: $PRIMARY_TAG"
          docker build -t "$PRIMARY_TAG" .
          
          # Tag with additional tags
          echo "$BUILT_TAGS" | while IFS= read -r tag; do
            if [ -n "$tag" ] && [ "$tag" != "$PRIMARY_TAG" ]; then
              echo "Tagging with: $tag"
              docker tag "$PRIMARY_TAG" "$tag"
            fi
          done
          
          # Push all tags to the local registry
          echo "üöÄ Pushing images to local registry..."
          echo "$BUILT_TAGS" | while IFS= read -r tag; do
            if [ -n "$tag" ]; then
              echo "Pushing: $tag"
              docker push "$tag"
            fi
          done
          
          echo "‚úÖ Image build and push completed!"

    - name: Deploy to EC2 Staging
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üöÄ Starting staging deployment..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          # Set Docker group ID for socket access
          export DOCKER_GROUP_ID=$(getent group docker | cut -d: -f3)
          export DOCKER_REGISTRY="${{ secrets.DOCKER_REGISTRY }}"

          # Set staging database environment variables
          export STAGING_DB_NAME="${{ secrets.STAGING_DB_NAME }}"
          export STAGING_DB_USER="${{ secrets.STAGING_DB_USER }}"
          export STAGING_DB_PASSWORD="${{ secrets.STAGING_DB_PASSWORD }}"
          
          # Deploy with Docker Swarm
          echo "üì¶ Deploying services..."
          
          # Force remove existing stack and wait for complete cleanup
          echo "üîÑ Ensuring clean deployment environment..."
          docker stack rm trends-earth-staging || true
          
          # Wait for all services to be completely removed
          echo "‚è≥ Waiting for stack cleanup to complete..."
          timeout=60
          while [ $timeout -gt 0 ]; do
            if ! docker service ls --format "{{.Name}}" | grep -q "trends-earth-staging"; then
              echo "‚úÖ Stack cleanup completed"
              break
            fi
            echo "‚è≥ Waiting for services to stop... ($timeout seconds remaining)"
            sleep 5
            timeout=$((timeout - 5))
          done
          
          # Additional cleanup - remove any lingering containers
          echo "üßπ Cleaning up any remaining containers..."
          docker ps -a --filter "name=trends-earth-staging" --format "{{.Names}}" | xargs -r docker rm -f || true
          
          # Remove any existing networks to ensure clean state
          echo "üåê Cleaning up overlay networks..."
          if docker network ls --format "{{.Name}}" | grep -q "trends-earth-staging_backend"; then
            echo "Removing existing network trends-earth-staging_backend..."
            # Force remove network even if it has active endpoints
            docker network rm trends-earth-staging_backend --force || true
            echo "‚úÖ Network cleanup completed"
            sleep 3
          fi
          
          # Ensure we're using the latest compose file
          echo "üìã Verifying compose file..."
          if [ ! -f "${{ env.COMPOSE_FILE }}" ]; then
            echo "‚ùå Compose file not found: ${{ env.COMPOSE_FILE }}"
            exit 1
          fi
          
          # Deploy fresh stack
          echo "üöÄ Deploying fresh stack..."
          docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-staging
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          
          # Check that all services are running with desired replicas
          echo "üìä Waiting for all services to be running..."
          max_wait=120
          wait_time=0
          
          while [ $wait_time -lt $max_wait ]; do
            # Check if all services have desired replicas running
            pending_services=$(docker service ls --filter "name=trends-earth-staging" --format "table {{.Name}}\t{{.Replicas}}" | grep -v "1/1" | wc -l)
            
            # Migrate when running correctly will run once then exit, so we expect 1 service to not be replicated
            if [ $pending_services -eq 2 ]; then  # Only header line and migrate line should remain if all other services are 1/1
              echo "‚úÖ All services are running"
              break
            fi
            
            echo "‚è≥ Waiting for services to be ready... ($wait_time/$max_wait seconds)"
            docker service ls --filter "name=trends-earth-staging"
            sleep 10
            wait_time=$((wait_time + 10))
          done
          
          if [ $wait_time -ge $max_wait ]; then
            echo "‚ö†Ô∏è Some services may not be fully ready after $max_wait seconds"
          fi
          
          # Check service status
          echo "üìä Final service status:"
          docker service ls | grep trends-earth-staging
          
          # Health check
          echo "üè• Performing health check..."
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "‚è≥ Health check attempt $attempt/$max_attempts..."
            
            # First check if port is listening
            if ! nc -z 127.0.0.1 3002 2>/dev/null; then
              echo "‚ö†Ô∏è Port 3002 is not listening yet"
            else
              echo "‚úÖ Port 3002 is listening"
            fi
            
            # Try the health check using 127.0.0.1 instead of localhost
            health_response=$(curl -f -s -w "HTTP_CODE:%{http_code}" http://127.0.0.1:3002/api-health 2>&1)
            curl_exit_code=$?
            
            if [ $curl_exit_code -eq 0 ]; then
              echo "‚úÖ Health check passed"
              echo "Response: $health_response"
              break
            else
              echo "‚è≥ Health check failed with exit code $curl_exit_code"
              echo "Response: $health_response"
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå Health check failed after $max_attempts attempts"
            echo "üîç Final debugging information:"
            echo "  - All running containers:"
            docker ps --filter "name=trends-earth-staging"
            echo "  - Manager service details:"
            docker service inspect trends-earth-staging_manager --format="{{json .Spec.TaskTemplate.ContainerSpec}}" || echo "Service not found"
            echo "  - Recent manager service logs:"
            docker service logs --tail 50 trends-earth-staging_manager || echo "No logs available"
            exit 1
          fi
          
          echo "üéâ Staging deployment completed successfully!"

    - name: Setup Staging Database
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          # Set staging database environment variables
          export STAGING_DB_HOST="${{ secrets.STAGING_DB_HOST }}"
          export STAGING_DB_PORT="${{ secrets.STAGING_DB_PORT }}"
          export STAGING_DB_NAME="${{ secrets.STAGING_DB_NAME }}"
          export STAGING_DB_USER="${{ secrets.STAGING_DB_USER }}"
          export STAGING_DB_PASSWORD="${{ secrets.STAGING_DB_PASSWORD }}"
          
          # Set production database environment variables (for data import)
          export PROD_DB_HOST="${{ secrets.PROD_DB_HOST }}"
          export PROD_DB_PORT="${{ secrets.PROD_DB_PORT }}"
          export PROD_DB_NAME="${{ secrets.PROD_DB_NAME }}"
          export PROD_DB_USER="${{ secrets.PROD_DB_USER }}"
          export PROD_DB_PASSWORD="${{ secrets.PROD_DB_PASSWORD }}"
          
          # Use defaults if not provided
          export PROD_DB_PORT="${PROD_DB_PORT:-5432}"
          export PROD_DB_NAME="${PROD_DB_NAME:-trendsearth}"
          
          # Set test user credentials
          export TEST_SUPERADMIN_EMAIL="${{ secrets.TEST_SUPERADMIN_EMAIL }}"
          export TEST_ADMIN_EMAIL="${{ secrets.TEST_ADMIN_EMAIL }}"
          export TEST_USER_EMAIL="${{ secrets.TEST_USER_EMAIL }}"
          export TEST_SUPERADMIN_PASSWORD="${{ secrets.TEST_SUPERADMIN_PASSWORD }}"
          export TEST_ADMIN_PASSWORD="${{ secrets.TEST_ADMIN_PASSWORD }}"
          export TEST_USER_PASSWORD="${{ secrets.TEST_USER_PASSWORD }}"
          
          # Run comprehensive database setup script (skip container creation since it's already deployed)
          chmod +x scripts/deployment/staging-database-init.sh
          ./scripts/deployment/staging-database-init.sh

    - name: Run integration tests
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/trends-earth-api-staging' }}
          
          # Set test user credentials for integration tests
          export TEST_SUPERADMIN_EMAIL="${{ secrets.TEST_SUPERADMIN_EMAIL }}"
          export TEST_ADMIN_EMAIL="${{ secrets.TEST_ADMIN_EMAIL }}"
          export TEST_USER_EMAIL="${{ secrets.TEST_USER_EMAIL }}"
          export TEST_SUPERADMIN_PASSWORD="${{ secrets.TEST_SUPERADMIN_PASSWORD }}"
          export TEST_ADMIN_PASSWORD="${{ secrets.TEST_ADMIN_PASSWORD }}"
          export TEST_USER_PASSWORD="${{ secrets.TEST_USER_PASSWORD }}"
          
          # Run integration tests script
          chmod +x scripts/deployment/run-integration-tests.sh
          ./scripts/deployment/run-integration-tests.sh

    - name: Cleanup security group access
      if: always()
      run: |
        # Remove the SSH access rule for the runner IP
        RUNNER_IP="${{ steps.security-group.outputs.runner-ip }}"
        if [ -n "$RUNNER_IP" ]; then
          echo "Removing SSH access for runner IP $RUNNER_IP from security group ${{ secrets.STAGING_SECURITY_GROUP_ID }}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ secrets.STAGING_SECURITY_GROUP_ID }}" \
            --protocol tcp \
            --port 22 \
            --cidr "${RUNNER_IP}/32" || true
          echo "Security group rule removed successfully"
        else
          echo "No runner IP found to remove from security group"
        fi
