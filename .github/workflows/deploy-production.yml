name: Deploy to Production

on:
  push:
    branches: [master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  IMAGE_NAME: trendsearth-api
  COMPOSE_FILE: docker-compose.prod.yml

jobs:
  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

    - name: Get runner IP and update security group
      id: security-group
      run: |
        # Get the public IP of the GitHub Actions runner
        RUNNER_IP=$(curl -s https://checkip.amazonaws.com)
        echo "Runner IP: $RUNNER_IP"
        echo "runner-ip=$RUNNER_IP" >> $GITHUB_OUTPUT
        
        # Add SSH access rule for the runner IP
        echo "Adding SSH access for runner IP $RUNNER_IP to security group ${{ secrets.PROD_SECURITY_GROUP_ID }}"
        aws ec2 authorize-security-group-ingress \
          --group-id "${{ secrets.PROD_SECURITY_GROUP_ID }}" \
          --protocol tcp \
          --port 22 \
          --cidr "${RUNNER_IP}/32" || true
        
        echo "Security group rule added successfully"

    - name: Set SSH port variable
      id: ssh-port
      run: |
        # Trim whitespace and newlines from the port
        PORT="${{ secrets.PROD_SSH_PORT || 22 }}"
        PORT=$(echo "$PORT" | tr -d '[:space:]')
        echo "port=$PORT" >> $GITHUB_OUTPUT

    - name: Build and push image on production server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üöÄ Building Docker image on production server..."
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          echo "üöÄ Starting production deployment build process..."
          
          # Ensure deployment utilities are executable
          chmod +x scripts/deployment_utils.py
          
          # Clean git workspace and checkout master branch using deployment utilities
          if ! python3 scripts/deployment_utils.py \
            --registry "${{ env.REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}" \
            clean-git --branch master; then
            echo "‚ùå Git workspace cleaning failed"
            exit 1
          fi
          
          # Configure Docker registry using deployment utilities
          if ! python3 scripts/deployment_utils.py \
            --registry "${{ env.REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}" \
            configure-registry; then
            echo "‚ùå Docker registry configuration failed"
            exit 1
          fi
          
          # Create image tags for production deployment
          BRANCH_NAME="${{ github.ref_name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          
          # Build and push images using deployment utilities
          if ! python3 scripts/deployment_utils.py \
            --registry "${{ env.REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}" \
            build-image \
            --tags "$BRANCH_NAME" "$BRANCH_NAME-$SHORT_SHA" "latest" \
            --commit-sha "${{ github.sha }}" \
            --no-cache; then
            echo "‚ùå Docker image build and push failed"
            exit 1
          fi
          
          echo "‚úÖ Production deployment build process completed!"

    - name: Deploy to EC2 Production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üöÄ Starting production deployment..."
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          export DOCKER_REGISTRY="${{ secrets.DOCKER_REGISTRY }}"

          # Validate compose file syntax before deploying (avoid printing full config)
          echo "üß™ Validating compose file syntax..."
          if docker compose -f ${{ env.COMPOSE_FILE }} config >/dev/null 2>&1; then
            echo "‚úÖ Compose file is valid"
          else
            echo "‚ùå Compose validation failed; showing first lines of error:"
            docker compose -f ${{ env.COMPOSE_FILE }} config 2>&1 | head -n 50
            exit 1
          fi
          
          # No custom network management: rely on docker stack deploy per compose.
          # We only preserve the execution network by avoiding stack removal when
          # active execution services are present.
          
          # Set version information for health checks
          export GIT_COMMIT_SHA="${{ github.sha }}"
          export GIT_BRANCH="${{ github.ref_name }}"
          export DEPLOYMENT_ENVIRONMENT="production"
          
          # Verify environment variables are set correctly
          echo "üìã Environment variables:"
          echo "  DOCKER_REGISTRY: $DOCKER_REGISTRY"
          echo "  GIT_COMMIT_SHA: $GIT_COMMIT_SHA"
          echo "  GIT_BRANCH: $GIT_BRANCH"
          
          # Compose will create overlay networks as defined in docker-compose.prod.yml

          echo "üì¶ Deploying services..."
          
          # Check if execution services are running that would prevent clean stack removal
          # Preserve execution network by avoiding stack removal if execution services are running
          active_executions=$(docker service ls --filter "label=service.type=execution" --format "{{.Name}}" | wc -l)
          if [ "$active_executions" -eq 0 ]; then
            # Fallback detection by name pattern if labels are missing
            active_executions=$(docker service ls --filter "name=execution-" --format "{{.Name}}" | wc -l)
          fi
          if [ $active_executions -gt 0 ]; then
            echo "‚ö†Ô∏è Found $active_executions active execution services - using rolling update instead of stack removal"
            echo "Active executions:"
            docker service ls --filter "name=execution-" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
            
            echo "üîÑ Performing rolling update deployment..."
            attempts=0
            until docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-prod; do
              attempts=$((attempts+1))
              if [ "$attempts" -ge 3 ]; then
                echo "‚ùå Stack deploy failed after $attempts attempts"
                exit 1
              fi
              echo "‚è≥ Stack deploy failed, retrying in 5s (attempt $attempts/3)..."
              sleep 5
            done
            
          else
            echo "No active executions found - can perform clean stack removal"
            # Safe to remove and redeploy stack
            if docker stack ls --format "{{.Name}}" | grep -q "trends-earth-prod"; then
              echo "Removing existing stack trends-earth-prod..."
              docker stack rm trends-earth-prod
              
              # Wait for complete cleanup
              echo "‚è≥ Waiting for stack cleanup to complete..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if ! docker service ls --format "{{.Name}}" | grep -q "trends-earth-prod"; then
                  echo "‚úÖ Stack cleanup completed"
                  break
                fi
                echo "‚è≥ Waiting for services to stop... ($timeout seconds remaining)"
                sleep 5
                timeout=$((timeout - 5))
              done
              
              # Additional cleanup - remove any lingering containers
              echo "üßπ Cleaning up any remaining containers..."
              docker ps -a --filter "name=trends-earth-prod" --format "{{.Names}}" | xargs -r docker rm -f || true
            fi
            
            # NOTE: Do not remove stack networks right before deploy. Compose will
            # re-create them as part of stack deploy. Removing them here can cause
            # race conditions where services try to attach to networks that are in
            # a transient deleted state, resulting in "network not found" errors.
            # Networks will be created/updated automatically by docker stack deploy.
            
            # Deploy fresh stack
            echo "‚è≥ Short wait to allow Swarm to finalize network teardown..."
            sleep 5
            # Remove stale backend network if it still exists (no executions running now)
            if docker network ls --format '{{.Name}}' | grep -Fx 'trends-earth-prod_backend' >/dev/null 2>&1; then
              echo "üßπ Removing stale backend network trends-earth-prod_backend if unused..."
              attached=$(docker network inspect trends-earth-prod_backend --format '{{ (index . 0).Containers }}' 2>/dev/null | grep -v 'map\[\]' || true)
              if [ -z "$attached" ]; then
                docker network rm trends-earth-prod_backend || true
                # brief settle time
                sleep 2
              else
                echo "‚ö†Ô∏è  Backend network has attached containers; skipping removal"
              fi
            fi

            # Remove stale execution network if it still exists (safe because no executions are running)
            if docker network ls --format '{{.Name}}' | grep -Fx 'trends-earth-prod_execution' >/dev/null 2>&1; then
              echo "üßπ Removing stale execution network trends-earth-prod_execution if unused..."
              attached=$(docker network inspect trends-earth-prod_execution --format '{{ (index . 0).Containers }}' 2>/dev/null | grep -v 'map\[\]' || true)
              if [ -z "$attached" ]; then
                docker network rm trends-earth-prod_execution || true
                sleep 2
              else
                echo "‚ö†Ô∏è  Execution network has attached containers; skipping removal"
              fi
            fi
            echo "üöÄ Deploying fresh stack..."
            attempts=0
            until docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-prod; do
              attempts=$((attempts+1))
              if [ "$attempts" -ge 3 ]; then
                echo "‚ùå Stack deploy failed after $attempts attempts"
                exit 1
              fi
              echo "‚è≥ Stack deploy failed, retrying in 5s (attempt $attempts/3)..."
              sleep 5
            done
          fi
          
          # Ensure we're using the latest compose file
          echo "üìã Verifying compose file..."
          if [ ! -f "${{ env.COMPOSE_FILE }}" ]; then
            echo "‚ùå Compose file not found: ${{ env.COMPOSE_FILE }}"
            exit 1
          fi
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          
          # Wait for all services to be ready using deployment utilities
          echo "üìä Waiting for all services to be running..."
          python3 scripts/deployment_utils.py \
            --registry "${{ secrets.DOCKER_REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}" \
            wait-services --stack-name "trends-earth-prod" --max-wait 120 || echo "‚ö†Ô∏è Some services may not be fully ready, continuing..."
          
          # Check service status
          echo "üìä Final service status:"
          docker service ls | grep trends-earth-prod
          
          # Health check using deployment utilities
          echo "üè• Performing health check..."
          if ! python3 scripts/deployment_utils.py \
            --registry "${{ secrets.DOCKER_REGISTRY }}" \
            --image-name "${{ env.IMAGE_NAME }}" \
            --app-path "${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}" \
            health-check --port 3001 --max-attempts 30; then
            echo "‚ùå Health check failed after $max_attempts attempts"
            echo "üîç Final debugging information:"
            echo "  - All running containers:"
            docker ps --filter "name=trends-earth-prod"
            echo "  - API service details:"
            docker service inspect trends-earth-prod_api --format="{{json .Spec.TaskTemplate.ContainerSpec}}" || echo "Service not found"
            echo "  - Recent API service logs:"
            docker service logs --tail 50 trends-earth-prod_api || echo "No logs available"
            
            echo "üîÑ Initiating automatic rollback..."
            
            # Rollback all services
            docker service rollback trends-earth-prod_api || echo "API rollback failed"
            docker service rollback trends-earth-prod_worker || echo "Worker rollback failed"  
            docker service rollback trends-earth-prod_beat || echo "Beat rollback failed"
            
            # Wait for rollback to complete
            sleep 60
            
            # Verify rollback health
            if curl -f http://localhost:3001/api-health > /dev/null 2>&1; then
              echo "‚úÖ Rollback successful - services restored"
            else
              echo "‚ùå Rollback verification failed - manual intervention required"
            fi
            
            exit 1
          fi
          
          echo "üéâ Production deployment completed successfully!"

    - name: Run basic integration tests
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          echo "üß™ Running basic integration tests for production..."
          
          # Test API health endpoint
          echo "‚è≥ Testing health endpoint..."
          if curl -f -s http://127.0.0.1:3001/api-health >/dev/null 2>&1; then
            echo "‚úÖ Health endpoint working"
          else
            echo "‚ùå Health endpoint failed"
            exit 1
          fi
          
          # Test API documentation endpoint
          echo "‚è≥ Testing API documentation endpoint..."
          if curl -f -s http://127.0.0.1:3001/api/docs/ >/dev/null 2>&1; then
            echo "‚úÖ API documentation endpoint working"
          else
            echo "‚ùå API documentation endpoint failed"
            exit 1
          fi
          
          # Test database connectivity through API
          echo "‚è≥ Testing basic API functionality..."
          # Use a simpler test that doesn't fail on expected auth errors
          api_response=$(curl -s -w "HTTP_CODE:%{http_code}" http://127.0.0.1:3001/api/v1/user/me 2>&1)
          echo "üîç API response: $api_response"
          
          if echo "$api_response" | grep -q "HTTP_CODE:200\|HTTP_CODE:401\|HTTP_CODE:403"; then
            echo "‚úÖ API responding correctly (authenticated endpoint returns expected status code)"
          else
            echo "‚ùå API not responding correctly: $api_response"
            echo "üîç Testing alternative endpoint for basic connectivity..."
            # Fallback test with swagger.json endpoint
            swagger_response=$(curl -s -w "HTTP_CODE:%{http_code}" http://127.0.0.1:3001/swagger.json 2>&1)
            echo "üîç Swagger response: $swagger_response"
            if echo "$swagger_response" | grep -q "HTTP_CODE:200"; then
              echo "‚úÖ API is responding (swagger endpoint working)"
            else
              echo "‚ùå API completely unresponsive"
              exit 1
            fi
          fi
          
          echo "‚úÖ All basic integration tests passed"

    - name: Notify Rollbar of deployment
      if: success()
      run: |
        echo "üîî Notifying Rollbar of successful deployment..."
        
        # Get deployment information
        ENVIRONMENT="production"
        REVISION="${{ github.sha }}"
        LOCAL_USERNAME="${{ github.actor }}"
        COMMENT="Deployed to production via GitHub Actions - Branch: ${{ github.ref_name }}, Commit: ${REVISION:0:7}"
        
        # Send deployment notification to Rollbar
        curl -X POST 'https://api.rollbar.com/api/1/deploy/' \
          -H 'Content-Type: application/json' \
          -d '{
            "access_token": "${{ secrets.ROLLBAR_SERVER_ACCESS_TOKEN }}",
            "environment": "'"$ENVIRONMENT"'",
            "revision": "'"$REVISION"'",
            "local_username": "'"$LOCAL_USERNAME"'",
            "comment": "'"$COMMENT"'"
          }'
        
        echo "‚úÖ Rollbar deployment notification sent successfully"

    - name: Cleanup security group access
      if: always()
      run: |
        # Remove the SSH access rule for the runner IP
        RUNNER_IP="${{ steps.security-group.outputs.runner-ip }}"
        if [ -n "$RUNNER_IP" ]; then
          echo "Removing SSH access for runner IP $RUNNER_IP from security group ${{ secrets.PROD_SECURITY_GROUP_ID }}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ secrets.PROD_SECURITY_GROUP_ID }}" \
            --protocol tcp \
            --port 22 \
            --cidr "${RUNNER_IP}/32" || true
          echo "Security group rule removed successfully"
        else
          echo "No runner IP found to remove from security group"
        fi
