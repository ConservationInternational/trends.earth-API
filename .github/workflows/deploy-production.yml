name: Deploy to Production

on:
  push:
    branches: [master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  IMAGE_NAME: trendsearth-api
  COMPOSE_FILE: docker-compose.prod.yml

jobs:
  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

    - name: Get runner IP and update security group
      id: security-group
      run: |
        # Get the public IP of the GitHub Actions runner
        RUNNER_IP=$(curl -s https://checkip.amazonaws.com)
        echo "Runner IP: $RUNNER_IP"
        echo "runner-ip=$RUNNER_IP" >> $GITHUB_OUTPUT
        
        # Add SSH access rule for the runner IP
        echo "Adding SSH access for runner IP $RUNNER_IP to security group ${{ secrets.PROD_SECURITY_GROUP_ID }}"
        aws ec2 authorize-security-group-ingress \
          --group-id "${{ secrets.PROD_SECURITY_GROUP_ID }}" \
          --protocol tcp \
          --port 22 \
          --cidr "${RUNNER_IP}/32" || true
        
        echo "Security group rule added successfully"

    - name: Set SSH port variable
      id: ssh-port
      run: |
        # Trim whitespace and newlines from the port
        PORT="${{ secrets.PROD_SSH_PORT || 22 }}"
        PORT=$(echo "$PORT" | tr -d '[:space:]')
        echo "port=$PORT" >> $GITHUB_OUTPUT

    - name: Build and push image on production server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "🚀 Building Docker image on production server..."
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          # Pull latest changes
          git fetch origin
          git reset --hard origin/master
          
          echo "✅ Currently on branch: $(git branch --show-current)"
          
          # Configure insecure registry on server if needed
          echo "📋 Configuring insecure registry on server..."
          sudo mkdir -p /etc/docker
          if [ ! -f /etc/docker/daemon.json ] || ! grep -q "insecure-registries" /etc/docker/daemon.json; then
            echo '{"insecure-registries":["${{ env.REGISTRY }}"]}' | sudo tee /etc/docker/daemon.json > /dev/null
            sudo systemctl restart docker
            sleep 10
          fi
          
          # Configure Docker client authentication
          mkdir -p $HOME/.docker
          
          # Create simplified Docker config without auth for production
          echo "🔐 Creating Docker config for production..."
          cat > $HOME/.docker/config.json <<-DOCKERCONFIG
          {
            "insecure-registries": ["${{ env.REGISTRY }}"]
          }
          DOCKERCONFIG
          echo "✅ Docker config created successfully"
          
          # Build the image with the appropriate tags
          echo "🔨 Building Docker image..."
          
          # Create production-specific tags
          REGISTRY="${{ env.REGISTRY }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          BRANCH_NAME="${{ github.ref_name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          
          BUILT_TAGS="$REGISTRY/$IMAGE_NAME:$BRANCH_NAME
          $REGISTRY/$IMAGE_NAME:$BRANCH_NAME-$SHORT_SHA
          $REGISTRY/$IMAGE_NAME:latest"
          
          # Build with the first tag (primary tag)
          PRIMARY_TAG="$REGISTRY/$IMAGE_NAME:$BRANCH_NAME"
          echo "Building with primary tag: $PRIMARY_TAG"
          docker build -t "$PRIMARY_TAG" .
          
          # Tag with additional tags
          echo "$BUILT_TAGS" | while IFS= read -r tag; do
            if [ -n "$tag" ] && [ "$tag" != "$PRIMARY_TAG" ]; then
              echo "Tagging with: $tag"
              docker tag "$PRIMARY_TAG" "$tag"
            fi
          done
          
          # Push all tags to the local registry
          echo "🚀 Pushing images to local registry..."
          echo "$BUILT_TAGS" | while IFS= read -r tag; do
            if [ -n "$tag" ]; then
              echo "Pushing: $tag"
              docker push "$tag"
            fi
          done
          
          echo "✅ Image build and push completed!"
          
          # Generate API documentation using the built container
          echo "📝 Generating OpenAPI documentation..."
          mkdir -p gefapi/static
          
          # Run the swagger generation and save to a temporary file first
          docker run --rm \
            "$PRIMARY_TAG" \
            sh -c "python3 generate_swagger.py" > gefapi/static/swagger.json || {
            echo "⚠️ API documentation generation failed, creating fallback..."
            # Create a minimal fallback swagger.json
            cat > gefapi/static/swagger.json <<-SWAGGER
          {
            "openapi": "3.0.0",
            "info": {
              "title": "Trends.Earth API",
              "version": "1.0.0",
              "description": "API documentation temporarily unavailable"
            },
            "paths": {}
          }
          SWAGGER
          }
          
          echo "✅ Swagger JSON generated successfully"
          
          # Debug: Verify static files are present
          echo "🔍 Verifying static files structure..."
          echo "Contents of gefapi/static:"
          ls -la gefapi/static/ || echo "No static directory found"
          if [ -d "gefapi/static/swagger-ui" ]; then
            echo "Contents of gefapi/static/swagger-ui:"
            ls -la gefapi/static/swagger-ui/
          else
            echo "No swagger-ui directory found"
          fi
          
          echo "✅ API documentation prepared"

    - name: Deploy to EC2 Production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "🚀 Starting production deployment..."
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          # Set Docker group ID for socket access
          export DOCKER_GROUP_ID=$(getent group docker | cut -d: -f3)
          export DOCKER_REGISTRY="${{ secrets.DOCKER_REGISTRY }}"
          
          # Deploy with Docker Swarm using rolling updates
          echo "📦 Deploying services with rolling updates..."
          
          # Ensure we're using the latest compose file
          echo "📋 Verifying compose file..."
          if [ ! -f "${{ env.COMPOSE_FILE }}" ]; then
            echo "❌ Compose file not found: ${{ env.COMPOSE_FILE }}"
            exit 1
          fi
          
          # Deploy stack - this will perform rolling updates automatically
          echo "🚀 Deploying stack with rolling updates..."
          docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-prod
          
          # Wait for rolling update to complete
          echo "⏳ Waiting for rolling update to complete..."
          
          # Monitor services for successful deployment
          echo "📊 Monitoring service deployment..."
          max_wait=180
          wait_time=0
          
          while [ $wait_time -lt $max_wait ]; do
            # Get the current state of services
            services_status=$(docker service ls --filter "name=trends-earth-prod" --format "{{.Name}}\t{{.Replicas}}")
            
            # Check if all services are converged (not updating)
            updating_services=$(docker service ls --filter "name=trends-earth-prod" --format "{{.Name}}\t{{.UpdateStatus}}" | grep -v "completed\|paused\|" | wc -l)
            
            if [ "$updating_services" -eq 0 ]; then
              # Check if all desired replicas are running
              pending_services=$(echo "$services_status" | grep -v "1/1" | grep -v "migrate" | wc -l)
              
              if [ "$pending_services" -eq 0 ]; then
                echo "✅ All services successfully deployed and running"
                break
              else
                echo "⏳ Waiting for services to reach desired state..."
              fi
            else
              echo "⏳ Rolling update in progress for $updating_services service(s)..."
            fi
            
            echo "Current service status:"
            echo "$services_status"
            
            sleep 10
            wait_time=$((wait_time + 10))
          done
          
          if [ $wait_time -ge $max_wait ]; then
            echo "⚠️ Rolling update did not complete within $max_wait seconds"
            echo "🔍 Current service status:"
            docker service ls --filter "name=trends-earth-prod" --format "table {{.Name}}\t{{.Replicas}}\t{{.UpdateStatus}}"
            
            echo "🔍 Checking for failed services..."
            failed_services=$(docker service ls --filter "name=trends-earth-prod" --format "{{.Name}}\t{{.UpdateStatus}}" | grep "paused\|rollback_paused" || true)
            
            if [ -n "$failed_services" ]; then
              echo "❌ Some services failed to update:"
              echo "$failed_services"
              echo "🔄 Automatic rollback will be handled by health check step"
            else
              echo "⚠️ Services may still be updating - proceeding to health check"
            fi
          fi
          
          # Check service status
          echo "📊 Final service status:"
          docker service ls | grep trends-earth-prod
          
          # Health check
          echo "🏥 Performing health check..."
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "⏳ Health check attempt $attempt/$max_attempts..."
            
            # First check if port is listening
            if ! nc -z 127.0.0.1 3001 2>/dev/null; then
              echo "⚠️ Port 3001 is not listening yet"
            else
              echo "✅ Port 3001 is listening"
            fi
            
            # Perform health check request
            health_response=$(curl -f -s -w "HTTP_CODE:%{http_code}" http://127.0.0.1:3001/api-health 2>&1)
            curl_exit_code=$?
            
            if [ $curl_exit_code -eq 0 ]; then
              echo "✅ Health check passed"
              echo "Response: $health_response"
              break
            else
              echo "⏳ Health check failed with exit code $curl_exit_code"
              echo "Response: $health_response"
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "❌ Health check failed after $max_attempts attempts"
            echo "🔍 Final debugging information:"
            echo "  - All running containers:"
            docker ps --filter "name=trends-earth-prod"
            echo "  - Manager service details:"
            docker service inspect trends-earth-prod_manager --format="{{json .Spec.TaskTemplate.ContainerSpec}}" || echo "Service not found"
            echo "  - Recent manager service logs:"
            docker service logs --tail 50 trends-earth-prod_manager || echo "No logs available"
            
            echo "🔄 Initiating automatic rollback..."
            
            # Rollback all services
            docker service rollback trends-earth-prod_manager || echo "Manager rollback failed"
            docker service rollback trends-earth-prod_worker || echo "Worker rollback failed"  
            docker service rollback trends-earth-prod_beat || echo "Beat rollback failed"
            
            # Wait for rollback to complete
            sleep 60
            
            # Verify rollback health
            if curl -f http://localhost:3001/api-health > /dev/null 2>&1; then
              echo "✅ Rollback successful - services restored"
            else
              echo "❌ Rollback verification failed - manual intervention required"
            fi
            
            exit 1
          fi
          
          echo "🎉 Production deployment completed successfully!"

    - name: Run basic integration tests
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          echo "🧪 Running basic integration tests for production..."
          
          # Test API health endpoint
          echo "⏳ Testing health endpoint..."
          if curl -f -s http://127.0.0.1:3001/api-health >/dev/null 2>&1; then
            echo "✅ Health endpoint working"
          else
            echo "❌ Health endpoint failed"
            exit 1
          fi
          
          # Test API documentation endpoint
          echo "⏳ Testing API documentation endpoint..."
          if curl -f -s http://127.0.0.1:3001/api/docs/ >/dev/null 2>&1; then
            echo "✅ API documentation endpoint working"
          else
            echo "❌ API documentation endpoint failed"
            exit 1
          fi
          
          # Test database connectivity through API
          echo "⏳ Testing basic API functionality..."
          # Use a simpler test that doesn't fail on expected auth errors
          api_response=$(curl -s -w "HTTP_CODE:%{http_code}" http://127.0.0.1:3001/api/v1/user/me 2>&1)
          echo "🔍 API response: $api_response"
          
          if echo "$api_response" | grep -q "HTTP_CODE:200\|HTTP_CODE:401\|HTTP_CODE:403"; then
            echo "✅ API responding correctly (authenticated endpoint returns expected status code)"
          else
            echo "❌ API not responding correctly: $api_response"
            echo "🔍 Testing alternative endpoint for basic connectivity..."
            # Fallback test with swagger.json endpoint
            swagger_response=$(curl -s -w "HTTP_CODE:%{http_code}" http://127.0.0.1:3001/swagger.json 2>&1)
            echo "🔍 Swagger response: $swagger_response"
            if echo "$swagger_response" | grep -q "HTTP_CODE:200"; then
              echo "✅ API is responding (swagger endpoint working)"
            else
              echo "❌ API completely unresponsive"
              exit 1
            fi
          fi
          
          echo "✅ All basic integration tests passed"

    - name: Notify Rollbar of deployment
      if: success()
      run: |
        echo "🔔 Notifying Rollbar of successful deployment..."
        
        # Get deployment information
        ENVIRONMENT="production"
        REVISION="${{ github.sha }}"
        LOCAL_USERNAME="${{ github.actor }}"
        COMMENT="Deployed to production via GitHub Actions - Branch: ${{ github.ref_name }}, Commit: ${REVISION:0:7}"
        
        # Send deployment notification to Rollbar
        curl -X POST 'https://api.rollbar.com/api/1/deploy/' \
          -H 'Content-Type: application/json' \
          -d '{
            "access_token": "${{ secrets.ROLLBAR_SERVER_ACCESS_TOKEN }}",
            "environment": "'"$ENVIRONMENT"'",
            "revision": "'"$REVISION"'",
            "local_username": "'"$LOCAL_USERNAME"'",
            "comment": "'"$COMMENT"'"
          }'
        
        echo "✅ Rollbar deployment notification sent successfully"

    - name: Cleanup security group access
      if: always()
      run: |
        # Remove the SSH access rule for the runner IP
        RUNNER_IP="${{ steps.security-group.outputs.runner-ip }}"
        if [ -n "$RUNNER_IP" ]; then
          echo "Removing SSH access for runner IP $RUNNER_IP from security group ${{ secrets.PROD_SECURITY_GROUP_ID }}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ secrets.PROD_SECURITY_GROUP_ID }}" \
            --protocol tcp \
            --port 22 \
            --cidr "${RUNNER_IP}/32" || true
          echo "Security group rule removed successfully"
        else
          echo "No runner IP found to remove from security group"
        fi
