name: Deploy to Production

on:
  push:
    branches: [master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  IMAGE_NAME: trendsearth-api
  COMPOSE_FILE: docker-compose.prod.yml

jobs:
  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Debug registry configuration
      run: |
        echo "Registry URL: '${{ env.REGISTRY }}'"
        echo "Registry URL length: ${#REGISTRY}"
        if [ -z "${{ env.REGISTRY }}" ]; then
          echo "ERROR: DOCKER_REGISTRY secret is empty or not set!"
          exit 1
        fi
      env:
        REGISTRY: ${{ env.REGISTRY }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build Docker image locally
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: false
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        outputs: type=docker,dest=/tmp/image.tar

    - name: Set SSH port variable
      id: ssh-port
      run: |
        # Trim whitespace and newlines from the port
        PORT="${{ secrets.PROD_SSH_PORT || 22 }}"
        PORT=$(echo "$PORT" | tr -d '[:space:]')
        echo "port=$PORT" >> $GITHUB_OUTPUT

    - name: Transfer and push image via SSH tunnel
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          echo "ğŸ”§ Preparing for image transfer..."
          
          # Create temporary directory for image transfer
          mkdir -p /tmp/docker-transfer
          rm -f /tmp/docker-transfer/image.tar
        
    - name: Copy image to EC2
      run: |
        echo "ğŸ“¦ Transferring Docker image to EC2..."
        
        # Create SSH key file
        echo "${{ secrets.PROD_SSH_KEY }}" > /tmp/ssh_key
        chmod 600 /tmp/ssh_key
        
        # Transfer the image
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          -i /tmp/ssh_key \
          -P ${{ steps.ssh-port.outputs.port }} \
          /tmp/image.tar \
          ${{ secrets.PROD_USERNAME }}@${{ secrets.PROD_HOST }}:/tmp/docker-transfer/
        
        # Clean up SSH key
        rm -f /tmp/ssh_key

    - name: Load and push image on EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "ğŸ³ Loading Docker image on EC2..."
          
          # Configure insecure registry on server if needed
          echo "ğŸ“‹ Configuring insecure registry on server..."
          sudo mkdir -p /etc/docker
          if [ ! -f /etc/docker/daemon.json ] || ! grep -q "insecure-registries" /etc/docker/daemon.json; then
            echo '{"insecure-registries":["${{ env.REGISTRY }}"]}' | sudo tee /etc/docker/daemon.json > /dev/null
            sudo systemctl restart docker
            sleep 10
          fi
          
          # Configure Docker client authentication
          mkdir -p $HOME/.docker
          REGISTRY_ESCAPED=$(echo "${{ env.REGISTRY }}" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          AUTH_ESCAPED=$(echo "${{ secrets.DOCKER_HTTP_SECRET }}" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          cat > $HOME/.docker/config.json << 'EOF'
          {
            "auths": {
              "REGISTRY_PLACEHOLDER": {
                "auth": "AUTH_PLACEHOLDER"
              }
            },
            "insecure-registries": ["REGISTRY_PLACEHOLDER"]
          }
          EOF
          # Replace placeholders with actual values
          sed -i "s|REGISTRY_PLACEHOLDER|${REGISTRY_ESCAPED}|g" $HOME/.docker/config.json
          sed -i "s|AUTH_PLACEHOLDER|${AUTH_ESCAPED}|g" $HOME/.docker/config.json
          
          # Load the image from tar file
          echo "ğŸ“¥ Loading image from tar file..."
          docker load -i /tmp/docker-transfer/image.tar
          
          # Get the image tags that were built
          BUILT_TAGS="${{ steps.meta.outputs.tags }}"
          
          # Push each tag to the local registry
          echo "ğŸš€ Pushing images to local registry..."
          echo "$BUILT_TAGS" | while IFS= read -r tag; do
            if [ -n "$tag" ]; then
              echo "Pushing: $tag"
              docker push "$tag"
            fi
          done
          
          # Clean up
          rm -f /tmp/docker-transfer/image.tar
          echo "âœ… Image transfer and push completed!"

    - name: Deploy to EC2 Production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "ğŸš€ Starting production deployment..."
          
          # Navigate to application directory
          cd ${{ secrets.PROD_APP_PATH || '/opt/trends-earth-api' }}
          
          # Pull latest changes
          git fetch origin
          git reset --hard origin/master
          
          # Set Docker group ID for socket access
          export DOCKER_GROUP_ID=$(getent group docker | cut -d: -f3)
          
          # Deploy with Docker Swarm
          echo "ğŸ“¦ Deploying services..."
          docker stack deploy -c ${{ env.COMPOSE_FILE }} --with-registry-auth trends-earth-prod
          
          # Wait for services to be ready
          echo "â³ Waiting for services to be ready..."
          sleep 30
          
          # Check service status
          echo "ğŸ“Š Service status:"
          docker service ls | grep trends-earth-prod
          
          # Health check
          echo "ğŸ¥ Performing health check..."
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:3001/api-health > /dev/null 2>&1; then
              echo "âœ… Health check passed"
              break
            else
              echo "â³ Health check attempt $attempt/$max_attempts failed, retrying..."
              sleep 10
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ Health check failed after $max_attempts attempts"
            echo "ğŸ”„ Initiating automatic rollback..."
            
            # Rollback all services
            docker service rollback trends-earth-prod_manager || echo "Manager rollback failed"
            docker service rollback trends-earth-prod_worker || echo "Worker rollback failed"  
            docker service rollback trends-earth-prod_beat || echo "Beat rollback failed"
            
            # Wait for rollback to complete
            sleep 60
            
            # Verify rollback health
            if curl -f http://localhost:3001/api-health > /dev/null 2>&1; then
              echo "âœ… Rollback successful - services restored"
            else
              echo "âŒ Rollback verification failed - manual intervention required"
            fi
            
            exit 1
          fi
          
          echo "ğŸ‰ Production deployment completed successfully!"
